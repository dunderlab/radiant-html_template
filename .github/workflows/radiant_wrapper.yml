name: Radiant Wrapper

on:
  workflow_dispatch:  # Allows manual trigger of the workflow
  push:               # Triggers the workflow on every push to the repository

jobs:
  radiant-wrapper:
    runs-on: ubuntu-latest  # Specifies the runner environment

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        # Clones the repository code into the workflow environment

      - name: Install Radiant-Wrapper
        run: |
          # Installs the Radiant-Wrapper package for building Android apps
          pip install radiant-wrapper

      - name: Execute Command in Docker Container
        run: |
          # Pull the Docker image used for building Android APKs
          docker pull dunderlab/radiant_p4a:latest
          
          # Get the distribution name from .p4a config file
          DIST_NAME=$(grep -E '^--dist_name ' .p4a | awk '{print $2}')
          
          # Handle Radiant Framework
          if [ -f "main.py" ] && grep -q "radiant.wrapper" main.py; then
              pip download  --no-deps radiant-framework
              unzip radiant_framework*.whl "radiant/*" -d .
          fi
          
          # Handle Django app setup
          if [ -f "$DIST_NAME/manage.py" ]; then
              pip download --no-deps django
              unzip django*.whl "django/*" -d .
              pip download  --no-deps radiant-wrapper
              unzip radiant_wrapper*.whl "radiant/*" -d .
              echo '
              from radiant.wrapper import server
              with open(".p4a", "r", encoding="utf-8") as f:
                for line in f:
                    if line.strip().startswith("--port"):
                        PORT = int(line.split()[1])
                    if line.strip().startswith("--dist_name"):
                        DIST_NAME = line.split()[1].strip()
              sys.path.append(os.path.join(os.path.dirname(__file__)))
              sys.path.append(os.path.join(os.path.dirname(__file__), DIST_NAME))
              server.main(DIST_NAME, ip="localhost", port=PORT)
              ' > main.py
          fi
          
          # Handle static HTML app setup
          # Creates main.py with simple HTTP server for static files
          if [ -f "index.html" ]; then
            echo '
            # CHANGES: default PORT + robust .p4a parsing + graceful signals + no sys.exit + allow_reuse_address
            import http.server
            import socketserver
            import sys
            import os
            import time
            import traceback
            import signal
            import socket
            
            # CHANGED: default port and safe .p4a parsing
            PORT = 5000
            try:
                with open(".p4a", "r", encoding="utf-8") as f:
                    for raw in f:
                        line = raw.strip()
                        if line.startswith("--port"):
                            PORT = int(line.split()[1])
                            break
            except Exception as e:
                print(f"[WARN] Cannot read .p4a or --port: {e}", file=sys.stderr)
            
            # CHANGED: concise HTTP logging
            class _Handler(http.server.SimpleHTTPRequestHandler):
                def log_message(self, fmt, *args):
                    sys.stdout.write("[HTTP] " + (fmt % args) + "\n")
                    sys.stdout.flush()
            
            # CHANGED: allow socket reuse for fast restarts
            class _TCPServer(socketserver.TCPServer):
                allow_reuse_address = True
            
            # CHANGED: cooperative shutdown
            _alive = True
            def _stop(_sig, _frm):
                global _alive
                _alive = False
            signal.signal(signal.SIGTERM, _stop)
            signal.signal(signal.SIGINT, _stop)
            
            def _wait_port(host, port, timeout=2.0):
                t0 = time.time()
                while time.time() - t0 < timeout:
                    try:
                        with socket.create_connection((host, port), timeout=0.5):
                            return True
                    except OSError:
                        time.sleep(0.1)
                return False
            
            def main():
                try:
                    with _TCPServer(("", PORT), _Handler) as httpd:
                        print(f"Serving at http://localhost:{PORT}")
                        sys.stdout.flush()
                        _wait_port("127.0.0.1", PORT, 2.0)  # ensure socket is listening
                        # CHANGED: handle one request at a time to honor signals
                        while _alive:
                            httpd.handle_request()
                except OSError as e:
                    # CHANGED: do not exit on bind errors; keep process alive to avoid WebView teardown crash
                    print(f"[FATAL] HTTP server failed on port {PORT}: {e}", file=sys.stderr)
                    traceback.print_exc()
                    while _alive:
                        time.sleep(0.5)
                except Exception:
                    print("[FATAL] Uncaught exception in server", file=sys.stderr)
                    traceback.print_exc()
                    while _alive:
                        time.sleep(0.5)
            
            if __name__ == "__main__":
                main()
                # CHANGED: avoid Py_Exit; idle until Android stops the process
                while _alive:
                    time.sleep(0.2)
            ' > main.py
          fi
      
          # Remove indentation (2-4 spaces) at the start of each line in main.py
          sed -i 's/^[[:space:]]\{2,4\}//' main.py
  
          # Cleanup downloaded wheel files
          if ls *.whl 1> /dev/null 2>&1; then rm *.whl; fi

          # Configure build inclusion/exclusion rules
          # Exclude Python bytecode files
          echo "*.pyc" > blacklist.txt
          
          # Include SQLite libraries and Python source files
          echo "sqlite3/*" >> whitelist.txt
          echo "lib-dynload/_sqlite3.so" >> whitelist.txt
          echo "*.py" >> whitelist.txt
          
          # Add build configuration settings to .p4a file
          echo "--no-byte-compile-python" >> .p4a
          echo "--private ." >> .p4a
          echo "--bootstrap webview" >> .p4a
          echo "--whitelist whitelist.txt" >> .p4a
          echo "" >> .p4a
  
          # Build the Android APK for ARM64 architecture
          radiant_p4a apk --arch arm64-v8a

      - name: Upload APKs as Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: Android APK # Name for the uploaded artifact
          path: ./*.apk # Path pattern to find APK files for upload